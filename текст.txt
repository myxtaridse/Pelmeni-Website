1. Изучение React. Какие технологии используются:
    - React (библиотека JS)
    - TypeScript (облегчает и делает код правильней)
    - Redux Toolkit (хранение данных: таких как картинки, изображения)
    - React Router v6 (подобие a.href, чтобы страница не обновлялась)
    - Axios + Fetch (осуществляет запрос на бэкенд)
    - React Hooks (хуки - взаимодействие с React - изменения данных)
    - React Context (контекст, глобальная переменная для хранения данных скрипта)
    - Prettier (форматирование кода, для чистого кода) - плагин
    - SCSS (стилизация)
    - Lodash

2. При создании React проекта в терминале npx create-react-app my-app
    npx - позволяет запускать программы, написанные на JS

3. Структура React-проекта:
    - Файл README.md - инструкция, как запускать проект, какие команды есть
    - package.json - опциональные настройки проекта, там названия проекта, описание, dependencies - важен, указывает какие вещи нужны для работы проекта
        важна команда start
    - package-lock.json - дополнительные настройки к выше файлу
    - папка node_modules - в которой хранятся доп программы для запуска React-приложения (похоже на сбор библиотек)
    - папка src
            - test - обычно не нужны
            - index.js - содержит import'ы, которые вызваны из библиотек, где весь код библиотеки импортируется в переменную
                    'import './index.css';' - просто запускает весь код
                    ReactDOM - преобразует логику React в HTML, создает точку запуска React-проекта
                    root.render - отображает, то, что есть в App


4. Вызов функции в React может быть в виде тега (<App />)
    Если функция возвращает HTML-разметку - это функциональный компонент
    Приложение состоит из маленьких компонентов, частей
    Компонент всегда с большой буквы, поскольку создался бы HTML-элемент
    Компонент представлет из себя ту же функцию, как App
        н-р, шапка сайта:
            function Header() {
                return (код с HTML-разметкой)
            }
        В самой разметке приложения вставляем компонент, 2 способа:
            - <Header /> - как разметка
            - {Header()} - как уже js-функция вызывается

    Компоненты делать в одном файле не нужно, создать папку компонентов  для создания структуры для проекта, для удобства
        разделеные компоненты по разным файлам в формате .jsx(корректней) (можно и .js), поскольку документ содержит jsx-разметку

    Фишка компонентов в том, что можно один и тот же код несколько раз переиспользовать
    Компонент можно переиспользовать на много раз, например, карточки продуктов задать один компонент с card-product
                и переиспользовать несколько раз
    ! - если нужна разная инфа на каждый продукт: 
            в компонентах можно передавать атрибуты 
            параметры важнее писать в файлах-компонентах
            у каждого компонента есть пропсы (props) - параметры, свойства
            props - 
                    в HTML-разметке <Header title='Пицца' price='500' /> прописали параметры 
                    которые нужно сохранить в файле компонента а именно в параметре функции function Header(props) {}
                        и если задать в функции вывод консоли 
                        console.log(props) => выведет объект с параметрами {title: 'Пицца', price: {500}}
                        !!! - значение можно передавать в виде числа(в price лучше числом, обязательно в фиргурные скобки), строк
            т.е. в параметре все переданные атрибуты в виде объекта
            
            props можно задать и в js-формате: {Header({title: 'Пицца', price: '500'})} - тоже самое!!!

            теперь, чтобы задать это на экран в самой функции компонента:
                function Header(props) {
                    return (
                        <h4>{props.title}</h4>
                    )
                } - выведет заданный атрибут 
                можно короче:
                function Header({ title }) {
                    return (
                        <h4>{title}</h4>  свойства преобразовались в переменные, иожно вывести без props, в виде объекта
                    )
                }


5. В React не HTML-разметка - это JSX - это тоже самое, что HTML, но с доп фишками, отличие 
        - тег закрывается <br /> иначе
        - jsx более строгий, чем HTML
        - в jsx можно запускать JS-код
            н-р, <div>
                    <h1>Hello World!</ h1>
                    {alert(123)}  -  запуститься! обязательны фигурные скобки
                 </ div>

                 
6. npm - отвечает за установку библиотек

7. SCSS - препроцессор, перед процессом что-то до (пре),
        т.е. перед тем, как браузеру отдать css, говорим преобразовать из scss в css
            Препроцессоры позволяют расширить возможности CSS: 
    В CSS дабы вызвать дочерний элемент все пишется в строчку
        н-р, .header .container .title {различные стили}
    Но в SCSS иначе можно писать .header {
                                    .container {
                                        .title {
                                            различные стили         ! В CSS так писать нельзя
                                        }
                                    }
                                }
    SCSS делает продвинутей написание стилей, облегчает написание:
        В CSS н-р: .block1 ul li:last-of-type {color: red}
        А в SCSS: .block1 { ul { li {} li:last-of-type {}}} - легче, можно дописать прямо внутри родителя

8. State (в компаненте) - состояние в React, как active - для выделения кнопки например, какой-то категории:
        переход категории из состояния неактивная - в активная
        Состояние - не только когда визуально что-то меняется, также измененность состояния за сайтом, н-р, каких-то данных, которые могут менять/изображать и тд
        Также например счетчик корзины, изменение кол-ва

9. Хуки UseState - написание кода без классов, благодаря сможем хранить данные, т.е. состояние чего-то
        хранение в библиотеке Redux
        для обновления переменной:
            cоздается переменная
                const [] = useState();
                - в квадратных скобках два состояния: (их можно называть по-разному)
                    1 - count - переменная, которая хранит значение, состояние 
                    2 - setCount - функция, которая обновляет значение,
                    также будет сохранять в переменную значение и заставит изменится компонент
                - в скобках функции useState() начальное значение, обычно 0 
            так, чтобы создать счетчик корзины:
                const [count, setCount] = useState(0);
                вместо значения, цифры кол-ва в корзине
                переменная, которая хранит значение кол-ва
                <span>{count}</span>

            Дабы обновить значение:
                производится будет через функцию, которая будет вызвана через кнопку
                const updateBtn = () => { анонимная функция
                    setCount(count + 1);   -> мы обновляем значение через функцию, оно само не может изменится как в JS count++, нужно через саму фукнцию обновления
                }
    Хук useState позволяет хранить данные в компоненте, и даже отобразить в компаненте
    Если данные нужно обновить, компонент должен перерисоваться и данные отобразить на странице
    Если данные не должны отобразиться, измениться можно хранить в обычной переменной
        const arr = [1, 2, 3];
    Если должны отобразиться/поменяться, использование useState
        const [count, setCount] = useState();


10. onclick в React:
        иначе работает, в JS onclick='function()'
    в React:
        onClick={ function }, второе слово с заглавной буквы
            
11. В jsx формате также иначу пишется class='' в тегной разметке
        Он пишется className=''

12. Когда на странице происходят какие-то изменения, н-р визуальные как изменение счетчика корзины, весь код не будет 
    обновляться, рендериться и обновляться каждый раз, в React'e есть Virtual DOM
        Virtual DOM - 
            есть Real DOM, который используется в JS, но он очень много будет весить, поскольку когда идет 
            обновление/создание/удаление контента, идет обновление всего кода проекта
        а Virtual DOM создает виртуальную копию кода проекта, сравнивает, какие имеются изменения в коде
        если что-то поменялось, он обновляет лишь тот фрагмент, в котором произошло изменение, т.е. только часть, 
        не весь код!


13. 1 - img-элементы стоит заносить в React, именно в папку public, путь можно не указывать длинный, лишь 
            src='img/logo.svg'
        статичные файлы
    2 - через импорты: 
          создать импорт, в котором будет хранится файла
          import logoSvg from '../img/logo.svg' - файл должен содержаться в src, т.е. где само приложение App
          src={logoSvg}
          через импорт вебпак будет доставать img-файл давать ему уникальное имя и сохраняет в переменной {logoSvg}

14. Переключатель категории вручную:
    Чтобы сделать переключатель категорий, н-р, пельменей(все, мясные, вегетарианские, сладкие)
        чтобы выделилась определенная кнопка категории, н-р, мясные, передаем class='active', стилизация
        которого задана в стилях, н-р, <li class='active'>Мясные</li>
        Но нужно предать переключатель:
            нужно определить индекс каждой категории через тернарный оператор определить либо активный класс, либо пустую строку
                <li class={'active' : ''}></li>
                Но нужно указать значение каждому через хук useState(), который сможет и обновить данные и сохранить
                function() {
                    const [activeIndex, setActive] = useState(0) -
                            activeIndex - обозначит индекс каждой категории
                            setActive - обновит и сохранит значение
                            useState(0) - начальный индекс - 0
                    return(
                        <ul>
                            <li class={activeIndex === индекс ? 'active' : ''}>Категория</li>
                                начинается значение с нуля, проверяет, если значение равно индексу, 
                                тогда данный <li> активен, нет - '', ничего
                        </ul>
                    )
                }
                Дабы шло переключение категорий нужно задать onClick с функцией, которая бы доставала индекс каждой категории
                (после useState анонимная функция) 
                const update = (index) => {
                    функция, которая обновляет значение
                    setActive(index)
                }
                чтобы вытащить индекс и выполнить функцию update на клик категории
                к <li добавляется анонимная функция onClick={() => update(0)}></li>
                в скобках - параметрах функции каждой категории разные индексы, начинается от 0
                функция при onClick анонимная, поскольку если вызвать просто update()
                случится много обновлений, она будет просто вызвана, без нажатия на кнопку

14. Переключатель категории - рендеринг спика:
        лучше создать массив, дабы преобразовать потом в jsx-разметку
        для всех категорий необходимо создать массив
        const arr = ["Все", "Мясные", "Сладкие", "Вегетарианские"];
        Дабы сократить список отрендарим его через метод map (изменит список)
        <ul>
            {
                arr.map((value, index) => {
                    return(
                        <li onClick={() => update(i)} class={activeIndex === i ? 'active' : ''}>
                            {value}
                        </li>
                    )
                })
            }
        </ul>
        map будет идти по массиву и преобразовать каждый индекс, active-нажатие, текст категории, от 0 до последнего в списке


15. В React нельзя дочерние элементы оставлять без родителя <div>
        <h1>123</h1>
        <h1>222</h1>  так нельзя оставлять, обязательно в контейнер
        <h1>333</h1>
        <div></div> как родитель можно представить пустым <></>, который будет хранить дочерние элементы
        можно создать <React.Fragment></React.Fragment>, дабы не создавался родительский компонент,
        но все же он будет, но не отрендарится (также как <></>)

Фрагменты в React

16. В формате .json обычно хранится вся инфа о продукте в массиве объекты на каждый
            {
                pelmenis.map(pelmenObj => {
                    return(
                        <PelmeniCard name={pelmenObj.name} imageUrl={pelmenObj.imageUrl} и т.д. />
                    );
                })
            }

17. name={obj.name}
    price={obj.price}
    imageUrl={obj.imageUrl}       можно сократить на передачу целого объекта {...obj}
    sizes={obj.sizes}
    types={obj.types}

    {...obj} - spread оператор, берет все свойства компонента, раскрывает их и помещает в сам компанент


18. Чтобы React хранил и работал в дальнейшем с рендеринг списком правильно, грамотно, чтобы он не путался
        необходим уникальный ключ родителя в рендеринг списке, н-р,
        <ul>
            {
                arr.map((value, index) => {
                    return(
                        <li key={i} onClick={() => update(i)} class={activeIndex === i ? 'active' : ''}>
                            {value}
                        </li>
                    )
                })
            }
        </ul>
        то есть тут <li> необходимо передать уникальный ключ
        если список статичный (не меняется, всегда тот же) можно использовать index
        но лучше им не пользоваться использовать что-то другое,
        н-р, у продуктов id, img, name и тд
        обычно key={obj.id/name/img}

    Благодаря key Virtual DOM будет правильней работать, рендеринг будет в нужном месте совершаться
    JSX-разметка уже уникальна


19. Условный рендеринг - открытие (отображение) какого-либо окна при нажатии
        Необходимо использовать useState
        В функции const [open, setOpen] = useState(false)
            false - окно закрыто, true - открыто
            создаются в коде два условия

            н-р, обязательно прикрепить атрибут нажатия на кнопку
            <p onClick={() => setOpen(!open)}>Открыть окно</p>
            !open - чтобы оно изменялось при нажатии

            задаем с условием значение, которое бы изменялось - open
            {
                open && (
                    <div className='окно'>
                        <ul>
                            <li>что-то</li>
                            <li>что-то</li>
                            <li>что-то</li>
                        </ul>
                    </div>
                )
            }
            то есть заданы оба условия, если open - true - окно откроется
            open - false - закроется

    Можно также через тернарный оператор 
        {open ? <div> : 'Окно закрыто'}

    Оба варинта возвращают одно нужное нам значение, if..else не удобно в этом случае


20. Хранение json проекта
        в файле хранить будет не правильно, бывает очень много информации, 
        должен быть сервер - бэкенд, с которого можно заправшивать какую-то инфу, например, товары определенной категории
        фронтенд запрашивает с бэка

    Сервис mockAPI - готовый сервис, который предоставляет возможность хранение данных в виде серверной части
    Избавляет от того, чтобы мы не писали свой бэкенд
    Там можно хранить небольшие данные, н-р, тестовые данные, пэт-проектов

    - хранение данных на удаленном сервере
    - можно хранить/генерировать данные 
    - можно обмениваться с пользователями данными

    .json - формат для хранения JS какой-то структуры данных
    его с данными нужно вынести в mockAPI
    - mockAPI будет хранить массив с товарами

    запрос на бэкенд (на массив с товарами) через JS - fetch - функция, которая делает запрос на массив на сервер 
    по адрессу самого mockAPI массива в браузере
    благодаря fetch идет GET-запрос на массив с товарами

    после вызова функции fetch совершаются методы н-р then - тогда
    "когда запрос - тогда сделать что-то"
    т.е. функция fetch('адрес на массив').then((res) => {return res}) res - response - ответ 
    ответ выходит не понятным, нужно его перевести
    метод fetch('адрес на массив').then((res) => {return res.json();}).then((json) => {return json})- .json выступает как переводчик
    ответ конвертируется в json, как и ранее был создан массив в папке src в формате .json

    ' Когда сделан запрос на массив в mockAPI, тогда верни в ответ - res, переконвертируй его в json-формат
            и тогда верни json - вернулся массив с товарами'

    Чтобы вывести весь массив 
    в рендеринга списка товаров обращаем внимание и создаем useState, поскольку нужно рендеринг спика изменить
    const [items, setItems] = useState([]);
    начальное значение пустой массив, поскольку наши товары представляют из себя массив
    определяем для рендеринга списка массив items, значение из котрого получим данные
    Нам нужно обновить данные в рендеринге из массива с бэка
    Изменим запрос
    fetch('адрес на массив').then((res) => {return res.json();}).then((arr) => {setItems(arr)})
    arr - поскольку получаем массив
    setItems(arr) - сохранит в себя массив и внесет в значение items,
    который в свою очередь вложен в рендеринг списка


    Но при таком способе идет очень много запросов на бэкенд, когда идет вызов метода setItems(arr)
    в реакте идет перерисовка, меняется state, очень много раз идет изменение и обновление материала на странице
    - тогда можно задать условие - если наш массив items пустой (!items.length), тогда отправлять запрос на бэкенд,
    чтобы он каждый раз запросы не делал, лишь при начале запуска страницы

    if (!items.length) {
        fetch("https://66028e549d7276a755538691.mockapi.io/items")
        .then((res) => {
            return res.json();
        })
        .then((arr) => {
            setItems(arr);
        });
    }

    Всего долго грузит и много запросов случается, и функция App() каждый раз обновляется, долгоо


    !!Но лучше всего задать всего один запрос на бэкенд и более его не делть!!

21. Существует React UseEffect - это также хук React, который позволяет синхронизировать компонент с внешней системой
        Данный хук получает функцию, которую будет вызывать если произойдет какой-то эффект
        Отлавливает какие-то действия, которые будут происходить в компоненте, н-р, обновится может, отрисоваться, удалится, исчезает
        3 жизненных цикла компонента: 
            1 - Монтирование: компонент создаётся и вставляется в модель DOM.
            2 - Обновление: компонент повторно визуализируется из-за изменений в его пропсах или состоянии.
            3 - Размонтирование: компонент удаляется из модели DOM.
        Может определить произошел ли первый рендер/не произошел

        Имеет два параметра, 1 - функция, 'Вызови функцию только в том случае, если
                             2 - условие, в нашем случае [] - начальное значение

        React.useEffect(() => {
            fetch("https://66028e549d7276a755538691.mockapi.io/items")
            .then((res) => {
                return res.json();
            })
            .then((arr) => {
                setItems(arr);
            });
        }, []);

        запрос будет всего один!! - при первом рендере приложения

22. Когда идет запрос на сервер, сделать заминку - скелетоны, то есть без изображений и текста, просто 
        как серые квадраты, где будет инфа, фейковые данные 
        бывает loading

        - есть определенный сайт skeletonreact, где можно сделать серый шаблон товара
        - код копируется в отдельный компонент Skeleton, устанавливается библиотека, если необходимо
        - сравнить с товарами, все ли сходится
        - вносим в прилоежение App
        импортируем, затем стоит создать useState для двух разных состояний loading
        const [isLoading, setLoading] = useState(true);
        true - для первого состояния - скелетона
        делаем тернарный оператор, чтобы вывело true/false в том месте, где идет рендеринг списка товаров
        {isLoading
            ? [...new Array(6)].map((_, i) => <Skeleton key={i} />)
            : items.map((obj) => {
                return <PelmeniBlock {...obj} key={obj.id} />;
        })}
        Читаем: Если идет Loading, первое состояние true, где создается 6 массивов с кодом Skeleton,
                6 - чтобы было не много 
                _ - нижнее подчеркивание в параметре обязательно, чтобы не было предупреждений от React
                у новых пустых массивов нет параметров
            начальное состояние Loading - true - Skeleton
        Но оно так и будет всегда давать true, значит нужна функция, чтобы изменить булеан
        вносим ее в наш запрос, когда идет получение запроса наш Loading был true,
        запрос произошел - вывелись товары, чтобы выпонилось false-условие, которое выводит товары
        React.useEffect(() => {
            fetch("https://66028e549d7276a755538691.mockapi.io/items")
            .then((res) => {
                return res.json();
            })
            .then((arr) => {
                setItems(arr);  
                //изменяем булиан
                setLoading(false);
            });
        }, []);
        Когда отрендарится код исчезает скелетон


23. React Router v6 - стандартная библиотека для маршрутизации в React. Позволяет перемещаться между
    различными компонентами в приложении React без обновления страницы при навигации пользователя.
    Позволяет также делать гибким адресс сайта

    Роуте с путем в виде '*' - подходит, когда путь неопределенен, ошибка в адресной строке
    когда не соответствует не одному другому Роуте
    <Route path="*" element={<EmptyCart />}></Route>

    Чтобы маршрутизация шла без обновления, нужно ссылку для перехода на др страницу обернуть в 
        <Link to='/'>различный контент</Link> - выведет на главную страницу


24. SCSS-модули:
    здесь стили даже если они находятся по разным файлам обязательно: .modules.scss, они не будут конфликтовать 
        из-за одиноково названных CSS-классов
        вызов класса будет через фигурные скобки
        import 'styles' from './example.module.scss'
        .root {}
        className={styles.root}
    SCSS-модуль будет уникализировать каждый из одинаковых имен, делает вебпак

25. window.scrollTo(0, 0); - для tsx компонента - pages, при открытии pages - скролл вначале, 
        поскольку браузер запоминает скролл прошлой страницы


26. Глобальный State (глобальное хранилище данных) 

        Сортировка по запросу HTTP на бэк
                mockapi.io/items?sortBy=rating&order=desc

                mockapi.io/items? - идет запрос к массиву, к его объектам - товарам
                после ? знака задаются параметры:
                    sortBy= - сортирует по чему-либо =rating - по рейтингу
                    &order=desc - будет сортировать от большего к меньшему, по убыванию
                        в моем случае от 4 (напитки) до 1 (мясные)
                    &order=asc - будет сортировать от меньшего к большему, по возрастанию
                        в моем случае от 1 (мясные) до 4 (напитки)

        Фильтрация по запросу 
            search - поиск параметров, н-р, можно найти по названию (title) товар
                mockapi.io/items?search=Пельмени&id=10
                    ? - после него задаются параметры
                    title - Пельмени, вывело 3 товара с таким наименованием
                    & - разделить запросов
                    id продукта - 10


         React.useEffect(() => {
            setIsLoading(true);
            fetch(
            `https://66028e549d7276a755538691.mockapi.io/items?${category}&sortBy=${sort}&order=${sortOrder}`
            )
            .then((res) => {
                return res.json();
            })
            .then((arr) => {
                setItems(arr);
                setIsLoading(false); //два действия нужны - это асинхронная функция, пока рендерятся пиццы, выставляется set(false)
            });
            window.scrollTo(0, 0);
        }, [categoryId, sortType]);

        
Контекст - глобальное значение, которое можно использовать на разных компонентах
    то есть задается useState с массивом в главном App.js далее по атрибутам компонентов передаем значение и ренедринг
         (функция обновления значения)
         вносятся они через параметры function({searchValue, setSearchValue})
         <Search searchValue="searchValue" setSearchValue="setSearchValue" />
         
         Но если много компонентов, через которые так каждый раз перескакивать через пропсы - Props Drilling - в глубь


27. Контролируемый input: 
        чтобы каждое действие зависело от React
        

28. Фильтрацию по названию можно провести с помощью JS через метод filter:
        const arr = [1, 2, 3, 4, 5];
        arr.filter(value => value >= 4) -> [4, 5]

29. includes - Этот метод определён у массивов и строк.     
    Для массивов: проверяет, есть ли искомый элемент в массиве.

30. Перенос слов в нижний регистр метод - .toLocalLowerCase()

31. Поиск по названию продукта. 2 способа:
        1. с помощью JS 
                const products = items
                .filter((obj) => {
                if (obj.name.toLowerCase().includes(searchValue)) {
                    return true;
                }
                return false;
                })
                .map((obj) => <PelmeniBlock key={obj.id} {...obj} />);

        items - все товары 
        .filter() - метод фильтрует объекты из товаров
            - выискивает obj.name с названиями
            - переносим все названия в нижний регистр toLowerCase()
            - .includes проверяет есть ли похожее введенное слово в input (с value={searchValue}) 
                    в наименованиях объектов с товарами
            - если есть возваращает их - true
            - если не совпадает наименование с поисковым словом - не показывает их

        2. через бэк
            const search = searchValue ? `search=${searchValue}` : ""; 
            - вводимое слово если есть в инпуте, тогда поиск в запросе по наименованию - &${search}
            `https://66028e549d7276a755538691.mockapi.io/items?${category}&sortBy=${sort}&order=${sortOrder}&${search}`
            - в массиве useEffect добавляем измнение запроса по наименованию


32. Пагинация это номера страниц внизу 1, 2, 3, 4 и т.д.
            когда много товаров на несколько страниц разбить или можно продлить вниз страниц "Открыть еще"

        mockAPI - не умеет высчитывать сколько страниц всего, поэтому самостоятельно сделали

    Библиотека пагинация - (npm i react-paginate)
        <>
        <ReactPaginate
            className={style.root}
            breakLabel="..."
            nextLabel=">"
            onPageChange={(event) => onChangePage(event.selected + 1)} -> берет индекс, выбранного номера страницы
            pageRangeDisplayed={4} -> выдает по 4 товара на стр аницу
            pageCount={4} -> всего страниц, но бэк сам должен высчитывать страницы
            previousLabel="<"
            renderOnZeroPageCount={null}
        />
        </>

    через useState(1) - задаем запросу значение page={currentPage} - начинается с 1, потом преобретает номера индекс + 1 нажатой страницы
    важно установить лимит запросу - &limit=4 - выдает по 4 товара на 1 страницу
    передаем компоненту функцию, которая вытягивает индекс нажатой страницы - 
                <Pagination
                    onChangePage={(number) => setCurrentPage(number)} //передается индекс выбранной страницы,
                    //передается значению currentPage, который вставляется в запрос page={currentPage}
                />
        передаем в пропс функции {onChangePage}
        затем включается в компонент пагинации - выше
        берет event выбранного элемента - выбранной страницы - и прибавляет + 1 к индексу
        event - объект с selected со значением нажатой кнопки

33. Если берем не наш элемент в scss модуле не привязать его классу стиль, тогда создается глобальный класс
            .root {
                :global {
                    .previous {
                        background-color: black;
                    }
                }
            }


34. UseContext - чтобы не перекидывать пропсы из useState по несколько раз из приложения в компонент, в компонент главнее компонента и тд
            Существует глобальный контекст - 
                     - В App создается переменная, которая создает Контекст - глобальную переменную
                        const название = React.createContext();
                     - обернули компоненты в созданный контекст с Provider - это компонент, 
                            который принимает значения из useState
                                ранее созданный useState, н-р, для поиска товаров
                                const [searchValue, setSearchValue] = useState('');
                                    setSearchValue - принимает значение input
                                    searchValue - вносится в запрос ?search={searchValue}
                        return(<>
                            <название.Provider value={{searchValue, setSearchValue}}>
                                приложение с компонентами
                                <Home searchValue={searchValue} />
                                    здесь можно оставить ибо тут сразу идет значение в компонент,
                                        без посредников
                            </название.Provider>
                        </>);
                     - В Search компоненте и в Header можно убрать пропсы, более не нужны, 
                            напрямую в index Search-компонента передаем глобальную переменную
                        Здесь создается переменная, которая вытаскивает пропсы глобальной переменной 
                            const { searchValue, setSearchValue } = React.useContext(название);
                     - не забываем про импорт в компонент и экспорт из главного приложения

            
35. Redux Toolkit - комплекс разных решений, мнржество функций, 
    Есть также MobX - библиотека, дающая разработчикам инструмент для глобального использования переменных 
    и методов между разными компонентами

    Данные комплексы, библиотеки помогают создавать хранилище данных, базу данных для фронта (грубо говоря)

Для маленьких приложений Context может подойти, но для крупных лучше использовать Redux

Если изменяется значение у одного из компонента, который зафиксирован в значении (value) передачи в компоненте Provider контекста -
    будет рендерится и сам измененный компонент со значением и сами значения компонента Provider контекста и 
        затем будут рендерится остальные значения Provider и после этого рендерятся остальные компоненты, 
            которые обладают значениями компонента Provider контекста

    Таким образом будет очень много перерисовок

    Redux - библиотека для управления состоянием приложения

    При изменении каких-либо данных вначале поступает иземенение во внешний хранитель, который зафиксирует изменение 
            и сделает перерисовку везде, где была изменена инфа, например, клиент решил изменить имя - направляется запрос 
            в глобальную переменную, он замечает новые изменения и где фигурирует имя - производит перерисовку

    !!Redux с React работает с помощью Контекста, прямиком данные оброкидывать нельзя 

    Redux Toolkit - библиотека со своими маленькими библиотеками
    Для использования Redux Toolkit в React'e необходима библиотека Redux React, в ней хранится логика для 
            объединения React и Redux


    В приложении при использовании какого-то глобального хранилища оборачиваем приложение в компонент Provider
            - что это?
            - Это компонент из библиотеки React Redux 
            - Он используется для того, чтобы сделать хранилище (в нашем случае Toolkit) доступным для приложения
            - Он оборачивает основной компонент приложения и делает хранилище доступным из любого компонента-контейнера
                 в дереве компонентов React

    
    Slice - это определенная секция со своими действиями, командами. Н-р, слайс корзины, слайс всех пицц-товаров, слайс категорий
    То есть каждый Slice содержит логику определенной секции

    для импортирования в приложение создаются две переменные
            import { useSelector, useDispatch } from 'react-redux';

            const value = useSelector((state) => state.counter.value); - внимает в себя значение, которое потом будет менятся, как в use State
            const dispatch = useDispatch();

            
            Хуки - 
                    useSelector() - отвечает за вытаскивание данных из хранилища, похож на useContext
                    useDispatch() - говорит сделай что-то, команды, в нашем случае, { increment, decrement, incrementByAmount }
            
            onClick={() => dispatch(increment())} - сделай увеличение числа
            
            мы передаем диспатч объект в виде инкремента
            а потом юзДиспатч вернет функцию



            Итак 
                Для начала создается файл store - где хранится вся логика, связанная с Redux Toolkit
                Переменная внимает в себя все Слайсы:
                    export const store = configureStore({
                    reducer: {
                        filterSlice,
                        itemsSlice,         //Слайсы
                        pageSlice,
                    },
                    });
                reducer - выполняет действия команды Слайсов

                В каждом Слайсе создается начальное значение (состояние) initialState
                создается в переменную Слайс createSlice()
                    Содержит в себе наименование - name,
                    initialState,
                    Действия reducer, в котором хранятся actions - команды
                    setCategoryId(state, action) {
                        //функция получает состояние и действие
                        //payload - внимает в себя ID категории
                        state.categoryId = action.payload; //метод, который меняет категорию
                    },
                    

                у нас есть функция const dispatch = useDispatch();
                        которая меняет наш state

                const onChangePageNumber = (id - параметр функции) => { 
                    dispatch(setCategoryId(id));
                };

                    - даем указание dispatch - изменить категорию через id, указываем на какую именно категорию, на новую
                        она придет из параметра функции (id)

                Без dispatch функция работать не будет, не будет выбираться новая категория

                сама функция представляет из себя объект 
                    {type: 'filters/setCategoryId', payload: 1}
                           'название name Слайса/функция, сам метод' , action.payload: id - внимает в себя ID категории
                тогда dispatch генерирует объект внимает в себя айди и передает функции, которая в свою очередь


36. Замена fetch на Axios
        Axios.get(
            `https://66028e549d7276a755538691.mockapi.io/items?page=${currentPage}&limit=4&${category}&sortBy=${sort}&order=${sortOrder}&${search}`
        ).then((res) => {
            dispatch(setItems(res.data));
            dispatch(setIsLoading(false));
        });
    Преимущества:
            - у него больше возможностей
            - сокращает написание кода, автоматическое конвертирование в json 
                    не нужно преобразовывать ответ в json как в fetch
            - совместим с многими браузерами
            - упрощают HTTP-запросы
            - возможность перехватывать HTTP-запросы
            - есть возможность одновременного выполнения нескольких запросов

37. Обращение к ссылкам DOM-элементов выполянется через хук useRef
        вызываем в переменную хук
            const inputRef = React.useRef();
        Самому инпуту привязываем ссылку через атрибут
            <input ref={inputRef} placeholder="Поиск.." />
        И в функции дальнейшее действие, н-р, сфокусироваться на элементе
            inputRef.current.focus();

38. Debounce - ожидание запроса на бэк из инпута
             - способ отложенного выполнения кода


39. Axios, Fetch - асинхронный запрос, то есть не ждет очереди, когда какой-то код выполнится
        будет независимо прогружаться, когда прогрузится, направит сразу
    Посмотреть event loop - как идет последовательность в асинхронности
    Асинхронный код, где отдельные части кода выполняются не по очереди,
        например, каждый код выполняется по-разному, по своему
            setTimeout - за указанное ему время в милисекундах
            fetch-запросы по ответу от бэка, как придет ответ, выполняются
            console - как сразу так и выполнятся и тд
    То есть в асинхронности нет очереди и некоторый код выполняется тогда когда придет время или ответ для выполнения

Async Await - ключевые слова, которые могут функцию превратить в асинхронную функцию

40. Promise - предоставляют удобный способ организации асинхронного кода.
            - это спец объект, который содержит свое состояние 
            - способна преобразовать синхронный код в асинхронный

        Axios возвращает Promise (Promise используют методы then и catch)
            Axios.get(
                `https://66028e549d7276a755538691.mockapi.io/items?page=${currentPage}&limit=4&${category}&sortBy=${sort}&order=${sortOrder}&${search}`
            ).then((res) => {
                dispatch(setItems(res.data));  //метод промиса
                dispatch(setIsLoading(false));  
            });
            
            метод catch - способен отлавливать ошибки в запросе, то есть в промисе, который вернул Axios
            '...then().catch((err) => {
                выведет в чем ошибка в консоли, если ошибка можно убрать лоадинг, чтобы страница была пуста, без скелетона
                dispatch(setIsLoading(false)); - когда нет запроса с бэка работает скелетон, отключаем его, пусто в продуктах
            })'

Чтобы отлавливать ошибку в JS есть функция try{} catch(error) {}
                                - если нет ошибки выполняется код в try{}
                                - если есть - в catch(error) {}
                            Применима в Async Await:
                                try { //выполнение запроса на бэк - все удачно, код выполняется, высвечиваются продукты
                                    const res = await Axios.get(`https...`);
                                    setItems(res.data); //отвечает за высвечивание товаров с бэка на сайте
                                    setIsLoading(false); // прекращается скелетон
                                } catch(error) { //ошибка после запроса, скелетон идет, продукты не приходят с бэка
                                    setIsLoading(false); // прекратим скелетон, пусто в области товаров
                                }

41. ThunkAPI В RTK: 
             - доп утилита в параметрах функции в createAsyncThunk - функция позволяющая в Redux использовать 
                    запросы на бэк, асинхронная функция
                export const fetchProducts = createAsyncThunk(
                "products/fetchProductsStatus",
                async ({ currentPage, category, sort, sortOrder, search }, thunkApi) => {
                    const response = await Axios.get(
                    `https://66028e549d7276a755538691.mockapi.io/items?page=${currentPage}&limit=4&${category}&sortBy=${sort}&order=${sortOrder}&${search}`
                    );
                    return response.data;
                }
                );
            
             - thunkApi - это объект, позволяет использовать диспатч внутри слайсов, отправлять диспатчи
                    получение стейта getState
                    Предоставляет возможность поработать с какими либо свойствами из функции CAT


42. В Redux можно создать свои Селекторы - JS-функции  
                    const categoryId = useSelector((state) => state.filterSlice.categoryId);
                    но можно такую функцию создать в самом Слайсе
                    const selectFilter = (state) => state.filterSlice;

43. Хук useLocation() - помогает определить на какой странице вы сейчас находитесь
        location.pagenames = '/cart'
    useLocation и window.location - не одно и то же

    Благодаря хуку можно скрывать какие-либо элементы, если, например, перешел на другую страницу
        Н-р, скрыть корзину в header при переходе в страницу-корзины:
            {location.pathname !== '/cart' && (<div className='header__cart'>...</div>)}

44. Хук useParams() - оповещает компонент о том, что нужно сделать перерисовку и вернуть в переменную 
                динамические параметры, которые будут переданы в адресной строке, если будут содержаться

                    Динамические параметры: <Router path='/product/:id' element />
                            :id - динамический параметр, может быть разным, берет айди от продукта на его странице
                    
                    Переменная: const {id} = useParams();
                        Установил в переменную динамический параметр из адресной строки
                    
                    Адресная строка: 'https://localhost:3000/product/:id(может быть любой адйи)'
                    С сменной Id меняются состовляющие страницы

45. <Outlet> - используется, когда sidebar и navbar - не должны быть изменчивы, а остальное должно меняться, внутри страницы
        В основном используется для больших вложенный роутов, приложений
        Для корректной работы приложения
        То есть имеется родительский элемент, содержащий тот же Header, который не изменчив на каждой странице
            А есть роуты дочерние, pages - например, изменяются при смене адреса, тогда их нужно 
                    вложить в родительский элемент, в тег <Outlet / >
                    В <Outlet /> будут рендерится все остальные динмические элементы 


46. TypeScript - то же самое что js, но TypeScript более типизированный, действия необходимо пояснять
                - сложный, но делает код правильней
            Типизация
                Пример, 
                    в JS мы функцию передаем так
                        function sum(a, b) {
                            return a + b;
                        }
                        sum(5, 5) -> 
                    Нет гарантии в том, что в значениях точно тип number
                    В JS можно передать преобразование строк в числа,
                    Но а если будет массив, тогда не сработает

                В этом случае TS может предупредить, что нужны только числа
                        function sum(a: number, b: number) {
                            return a + b;
                        }
                        sum(5, 5) -> 

                Предупредит, что неправильное значение введенно
                Помогает обнаружить ошибки еще на этапе написания кода

                Браузер не поддерживает TypeScript
                Поэтому необходимо будет конвертировать его в JS

    TypeScript - тот же самый JS, где есть все те же методы, массивы, объекты, функции,
        переменные и тп.
        Но позволяет типизировать код! Объяснить что чем является
        Позволяет уменьшить кол-во багов правильное написание типизации
        Позволяет писать более понятный и читаемый код

    Отличие от JS в том, что мы передаем тип
        let a = 1; // number  -  JS
        let a: number = 1; // number  -  TS
        Если мы определим в TS тип "number" а в значении пропишем строчку, TS будет ругаться
        let a: number = "1"; // ошибка!! number - не string "1"
        let a: string = "1"; // верно

    TS автоматически может определить тип переменных
    Если передать массив с числами
        const arr = [1, 2, 3]; // TS определит number[] - числовой массив
    И так с любыми типами!
        const arr = ["1", "2", "3"]; // TS определит string[] - строчный массив

    Строгая типизация. Когда тип boolean, передавать только true/false
        let isAuth = true; // пользователь авторизован

        Но если передать
        isAuth = 1/0;
        TS не поймет, он будет ждать лишь true/false

        Можно применить Boolean, который бы вывел эти значения
        isAuth = Boolean(1) // true
        isAuth = Boolean(0) // false
        И так далее

    Но в типах возможно передавать несколько значений (или)
        let fullName: string | null = "Вася"; // или в TS передается -> "|"
        fullName = null;
    Переменная внимает в себя либо строчку, либо пустое значение null
    Дабы не было ошибки

    Если указаны в функции несколько параметров, но одного нет, тогда можно перевести в опциональный параметр
        function sayHello(name: string, years?: number) { //years?: number - опциональный, 
                    выведет либо number, сколько лет указано, либо undefined, т.е. ничего нет, неопределенен

            console.log(`Привет, ${name}. Тебе правда ${years} лет?);
        }
        sayHello('Петя', 15); //Привет, Петя. Тебе правда 15 лет?
        sayHello('Петя'); //Привет, Петя. Тебе правда undefined лет? 
                TS не ругается, поскольку второй параметр опциональный


47. Оператор опциональной последовательности '?.' в TypeScript
        позволяет получить значение свойства без необходимости проверять промежуточные свойства в ней на существование
        if (inputRef.current) {
            inputRef.current.focus();  -> -> inputRef.current?.focus(); - короче!!
        }

        Если нет значения у свойства - приложение не будет ломаться
         

48. Типизация для функции

        function: () => void;

    В данном случае функция не получает ни одного аргумента 

    void - примитивный тип данных, возвращает пустоту, ничего, по заврешению определенных действий,
    которые выполняет функция он НИКАКИХ значений НЕ возваращает
    void - всегда возвращает undefined
    Тип void в TypeScript можно назвать чем-то вроде противоположности типа "any"
    

    function: (id: number) => void;

    В данном случае уже функция получает один аргумент, который мы также типизируем 
        функция получает один аргумент i с типом числовым


49. local Storage - локальное хранилище
        По определенному домену будет хранить какие-либо данные, даже при перезагрузке странице
        В любой момент можно получить инфу

        В хранилище нельзя хранить js-код, объект, н-р, массив
        Сохранение идет лишь в виде строчки

        Добавление в хранилище инфы - window.localStorage.setItem(key, value):
        
                window.localStorage.setItem("test", "123")
        
        Вытащить из хранилища с помощью ключа 

                window.localStorage.getItem('test) --> '123'

        При сохранении в хранилище обязательно код нужно переконвертировать в строчку и обратно из строчки
                window.localStorage.setItem('test', JSON.stringify([1, 2, 3]))
                JSON.parse(window.localStorage.getItem('test')) --> [1, 2, 3]

50. utils - папка для вспомогательных функций

51.     Произвели сборку проекта npm run build
        Сжатый js-проект составляет 90килобайт
        Когда он доходит до цифры от 300 килобайт тогда стоит лучше применить оптимизацию,
    
    А имеено разделение кода - код сплитинг - один большой файл (бандл) на маленькие - chunk - кусочек большого бандла
     То есть, есть динамический импорт
        import('./math').then(math => {         import math from './math';
            console.log(math.add(16, 26)) -->   math(16, 26)
        })

52. Ленивая подгрузка файла
        Когда открыта главная страница, чтобы не подгружались другие страницы, отправить их в ленивую подгрузку
        Только тогда, когда пользователь переходит на страницу Cart, только тогда она подгружается

            const Cart = React.lazy(
            () => import(/* webpackChunkName: "Cart" */ "./pages/Cart")
            );

        Перед загрузкой сделать Loading (компонент с колесиком загрузки)
            <Route
            path="cart"
            element={
                <React.Suspense fallback={<Loading />}>
                <Cart />
                </React.Suspense>
            }
            />

    Минус в том, что когда нужно страницу подгрузить с сервера, React.lazy не сумеет сделать рендеринг
            со стороны сервера

53. Также вместо React.lazy используют библиотеку React Loadable / Loadable Component
        Дабы произвести плюсом разделение кода (бандла) и ленивый рендеринг со стороны сервера также

            const Cart = Loadable({
                loader: () => import('./pages/Cart'),
                loading: <Loading />,
            })

54. Tree Shaking - механизм устранения неиспользуемого кода, т.е. который импортирован в файл, но не используется
        Относится к вебпаку

55. Reexport - чтобы было меньше импорта в различных файлах

        export { default as Sort } from "./Sort";
        В отдельном файле импортируем и экспортируем данным образом файл

        а в страничных файлах получилась одна строчка
        import {SkeletProduct, CartEmpty, Loading, NotFoundBlock и т.д.} from '../components/index'

    Данный способ помогает также некоторые компоненты не подгружать сейчас, а только при рендере с ним страницы
        Относится к Tree Shaking
        